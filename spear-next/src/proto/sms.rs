// This file is @generated by prost-build.
/// Node basic information / 节点基本信息
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Node {
    /// Node unique identifier / 节点唯一标识符
    #[prost(string, tag = "1")]
    pub uuid: ::prost::alloc::string::String,
    /// Node IP address / 节点IP地址
    #[prost(string, tag = "2")]
    pub ip_address: ::prost::alloc::string::String,
    /// Node port / 节点端口
    #[prost(int32, tag = "3")]
    pub port: i32,
    /// Node status (active, inactive, etc.) / 节点状态
    #[prost(string, tag = "4")]
    pub status: ::prost::alloc::string::String,
    /// Last heartbeat timestamp / 最后心跳时间戳
    #[prost(int64, tag = "5")]
    pub last_heartbeat: i64,
    /// Node registration timestamp / 节点注册时间戳
    #[prost(int64, tag = "6")]
    pub registered_at: i64,
    /// Additional node metadata / 额外节点元数据
    #[prost(map = "string, string", tag = "7")]
    pub metadata: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
}
/// Node resource information / 节点资源信息
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct NodeResource {
    /// Node unique identifier / 节点唯一标识符
    #[prost(string, tag = "1")]
    pub node_uuid: ::prost::alloc::string::String,
    /// CPU usage percentage (0-100) / CPU使用率百分比 (0-100)
    #[prost(double, tag = "2")]
    pub cpu_usage_percent: f64,
    /// Memory usage percentage (0-100) / 内存使用率百分比 (0-100)
    #[prost(double, tag = "3")]
    pub memory_usage_percent: f64,
    /// Total memory in bytes / 总内存字节数
    #[prost(int64, tag = "4")]
    pub total_memory_bytes: i64,
    /// Used memory in bytes / 已使用内存字节数
    #[prost(int64, tag = "5")]
    pub used_memory_bytes: i64,
    /// Available memory in bytes / 可用内存字节数
    #[prost(int64, tag = "6")]
    pub available_memory_bytes: i64,
    /// Disk usage percentage (0-100) / 磁盘使用率百分比 (0-100)
    #[prost(double, tag = "7")]
    pub disk_usage_percent: f64,
    /// Total disk space in bytes / 总磁盘空间字节数
    #[prost(int64, tag = "8")]
    pub total_disk_bytes: i64,
    /// Used disk space in bytes / 已使用磁盘空间字节数
    #[prost(int64, tag = "9")]
    pub used_disk_bytes: i64,
    /// Network receive bytes per second / 网络接收字节数每秒
    #[prost(int64, tag = "10")]
    pub network_rx_bytes_per_sec: i64,
    /// Network transmit bytes per second / 网络发送字节数每秒
    #[prost(int64, tag = "11")]
    pub network_tx_bytes_per_sec: i64,
    /// Load average (1 minute) / 负载平均值 (1分钟)
    #[prost(double, tag = "12")]
    pub load_average_1m: f64,
    /// Load average (5 minutes) / 负载平均值 (5分钟)
    #[prost(double, tag = "13")]
    pub load_average_5m: f64,
    /// Load average (15 minutes) / 负载平均值 (15分钟)
    #[prost(double, tag = "14")]
    pub load_average_15m: f64,
    /// Resource update timestamp / 资源更新时间戳
    #[prost(int64, tag = "15")]
    pub updated_at: i64,
    /// Additional resource metadata / 额外资源元数据
    #[prost(map = "string, string", tag = "16")]
    pub resource_metadata: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
}
/// Node registration request / 节点注册请求
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RegisterNodeRequest {
    #[prost(message, optional, tag = "1")]
    pub node: ::core::option::Option<Node>,
}
/// Node registration response / 节点注册响应
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RegisterNodeResponse {
    #[prost(bool, tag = "1")]
    pub success: bool,
    #[prost(string, tag = "2")]
    pub message: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub node_uuid: ::prost::alloc::string::String,
}
/// Node update request / 节点更新请求
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateNodeRequest {
    #[prost(string, tag = "1")]
    pub uuid: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub node: ::core::option::Option<Node>,
}
/// Node update response / 节点更新响应
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateNodeResponse {
    #[prost(bool, tag = "1")]
    pub success: bool,
    #[prost(string, tag = "2")]
    pub message: ::prost::alloc::string::String,
}
/// Node deletion request / 节点删除请求
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteNodeRequest {
    #[prost(string, tag = "1")]
    pub uuid: ::prost::alloc::string::String,
}
/// Node deletion response / 节点删除响应
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteNodeResponse {
    #[prost(bool, tag = "1")]
    pub success: bool,
    #[prost(string, tag = "2")]
    pub message: ::prost::alloc::string::String,
}
/// Heartbeat request / 心跳请求
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct HeartbeatRequest {
    #[prost(string, tag = "1")]
    pub uuid: ::prost::alloc::string::String,
    #[prost(int64, tag = "2")]
    pub timestamp: i64,
    /// Health check information / 健康检查信息
    #[prost(map = "string, string", tag = "3")]
    pub health_info: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
}
/// Heartbeat response / 心跳响应
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct HeartbeatResponse {
    #[prost(bool, tag = "1")]
    pub success: bool,
    #[prost(string, tag = "2")]
    pub message: ::prost::alloc::string::String,
    #[prost(int64, tag = "3")]
    pub server_timestamp: i64,
}
/// List nodes request / 列出节点请求
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListNodesRequest {
    /// Optional status filter / 可选状态过滤器
    #[prost(string, tag = "1")]
    pub status_filter: ::prost::alloc::string::String,
}
/// List nodes response / 列出节点响应
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListNodesResponse {
    #[prost(message, repeated, tag = "1")]
    pub nodes: ::prost::alloc::vec::Vec<Node>,
}
/// Get node request / 获取节点请求
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetNodeRequest {
    #[prost(string, tag = "1")]
    pub uuid: ::prost::alloc::string::String,
}
/// Get node response / 获取节点响应
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetNodeResponse {
    #[prost(bool, tag = "1")]
    pub found: bool,
    #[prost(message, optional, tag = "2")]
    pub node: ::core::option::Option<Node>,
}
/// Update node resource request / 更新节点资源请求
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateNodeResourceRequest {
    #[prost(message, optional, tag = "1")]
    pub resource: ::core::option::Option<NodeResource>,
}
/// Update node resource response / 更新节点资源响应
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateNodeResourceResponse {
    #[prost(bool, tag = "1")]
    pub success: bool,
    #[prost(string, tag = "2")]
    pub message: ::prost::alloc::string::String,
}
/// Get node resource request / 获取节点资源请求
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetNodeResourceRequest {
    #[prost(string, tag = "1")]
    pub node_uuid: ::prost::alloc::string::String,
}
/// Get node resource response / 获取节点资源响应
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetNodeResourceResponse {
    #[prost(bool, tag = "1")]
    pub found: bool,
    #[prost(message, optional, tag = "2")]
    pub resource: ::core::option::Option<NodeResource>,
}
/// List node resources request / 列出节点资源请求
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListNodeResourcesRequest {
    /// Optional filter by node UUIDs / 可选按节点UUID过滤
    #[prost(string, repeated, tag = "1")]
    pub node_uuids: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
/// List node resources response / 列出节点资源响应
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListNodeResourcesResponse {
    #[prost(message, repeated, tag = "1")]
    pub resources: ::prost::alloc::vec::Vec<NodeResource>,
}
/// Get node with resource request / 获取节点及资源请求
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetNodeWithResourceRequest {
    #[prost(string, tag = "1")]
    pub uuid: ::prost::alloc::string::String,
}
/// Get node with resource response / 获取节点及资源响应
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetNodeWithResourceResponse {
    #[prost(bool, tag = "1")]
    pub found: bool,
    #[prost(message, optional, tag = "2")]
    pub node: ::core::option::Option<Node>,
    #[prost(message, optional, tag = "3")]
    pub resource: ::core::option::Option<NodeResource>,
}
/// Generated client implementations.
pub mod node_service_client {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    /// Node management service definition / 节点管理服务定义
    #[derive(Debug, Clone)]
    pub struct NodeServiceClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl NodeServiceClient<tonic::transport::Channel> {
        /// Attempt to create a new client by connecting to a given endpoint.
        pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
        where
            D: TryInto<tonic::transport::Endpoint>,
            D::Error: Into<StdError>,
        {
            let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
            Ok(Self::new(conn))
        }
    }
    impl<T> NodeServiceClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + std::marker::Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + std::marker::Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> NodeServiceClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
            >>::Error: Into<StdError> + std::marker::Send + std::marker::Sync,
        {
            NodeServiceClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// Register a new node / 注册新节点
        pub async fn register_node(
            &mut self,
            request: impl tonic::IntoRequest<super::RegisterNodeRequest>,
        ) -> std::result::Result<
            tonic::Response<super::RegisterNodeResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/sms.NodeService/RegisterNode",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("sms.NodeService", "RegisterNode"));
            self.inner.unary(req, path, codec).await
        }
        /// Update an existing node / 更新现有节点
        pub async fn update_node(
            &mut self,
            request: impl tonic::IntoRequest<super::UpdateNodeRequest>,
        ) -> std::result::Result<
            tonic::Response<super::UpdateNodeResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/sms.NodeService/UpdateNode",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("sms.NodeService", "UpdateNode"));
            self.inner.unary(req, path, codec).await
        }
        /// Delete a node / 删除节点
        pub async fn delete_node(
            &mut self,
            request: impl tonic::IntoRequest<super::DeleteNodeRequest>,
        ) -> std::result::Result<
            tonic::Response<super::DeleteNodeResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/sms.NodeService/DeleteNode",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("sms.NodeService", "DeleteNode"));
            self.inner.unary(req, path, codec).await
        }
        /// Send heartbeat / 发送心跳
        pub async fn heartbeat(
            &mut self,
            request: impl tonic::IntoRequest<super::HeartbeatRequest>,
        ) -> std::result::Result<
            tonic::Response<super::HeartbeatResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/sms.NodeService/Heartbeat",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new("sms.NodeService", "Heartbeat"));
            self.inner.unary(req, path, codec).await
        }
        /// List all nodes / 列出所有节点
        pub async fn list_nodes(
            &mut self,
            request: impl tonic::IntoRequest<super::ListNodesRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListNodesResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/sms.NodeService/ListNodes",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new("sms.NodeService", "ListNodes"));
            self.inner.unary(req, path, codec).await
        }
        /// Get specific node / 获取特定节点
        pub async fn get_node(
            &mut self,
            request: impl tonic::IntoRequest<super::GetNodeRequest>,
        ) -> std::result::Result<
            tonic::Response<super::GetNodeResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static("/sms.NodeService/GetNode");
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new("sms.NodeService", "GetNode"));
            self.inner.unary(req, path, codec).await
        }
        /// Update node resource information / 更新节点资源信息
        pub async fn update_node_resource(
            &mut self,
            request: impl tonic::IntoRequest<super::UpdateNodeResourceRequest>,
        ) -> std::result::Result<
            tonic::Response<super::UpdateNodeResourceResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/sms.NodeService/UpdateNodeResource",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("sms.NodeService", "UpdateNodeResource"));
            self.inner.unary(req, path, codec).await
        }
        /// Get node resource information / 获取节点资源信息
        pub async fn get_node_resource(
            &mut self,
            request: impl tonic::IntoRequest<super::GetNodeResourceRequest>,
        ) -> std::result::Result<
            tonic::Response<super::GetNodeResourceResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/sms.NodeService/GetNodeResource",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("sms.NodeService", "GetNodeResource"));
            self.inner.unary(req, path, codec).await
        }
        /// List node resources / 列出节点资源信息
        pub async fn list_node_resources(
            &mut self,
            request: impl tonic::IntoRequest<super::ListNodeResourcesRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListNodeResourcesResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/sms.NodeService/ListNodeResources",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("sms.NodeService", "ListNodeResources"));
            self.inner.unary(req, path, codec).await
        }
        /// Get node with resource information / 获取节点及其资源信息
        pub async fn get_node_with_resource(
            &mut self,
            request: impl tonic::IntoRequest<super::GetNodeWithResourceRequest>,
        ) -> std::result::Result<
            tonic::Response<super::GetNodeWithResourceResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/sms.NodeService/GetNodeWithResource",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("sms.NodeService", "GetNodeWithResource"));
            self.inner.unary(req, path, codec).await
        }
    }
}
/// Generated server implementations.
pub mod node_service_server {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    /// Generated trait containing gRPC methods that should be implemented for use with NodeServiceServer.
    #[async_trait]
    pub trait NodeService: std::marker::Send + std::marker::Sync + 'static {
        /// Register a new node / 注册新节点
        async fn register_node(
            &self,
            request: tonic::Request<super::RegisterNodeRequest>,
        ) -> std::result::Result<
            tonic::Response<super::RegisterNodeResponse>,
            tonic::Status,
        >;
        /// Update an existing node / 更新现有节点
        async fn update_node(
            &self,
            request: tonic::Request<super::UpdateNodeRequest>,
        ) -> std::result::Result<
            tonic::Response<super::UpdateNodeResponse>,
            tonic::Status,
        >;
        /// Delete a node / 删除节点
        async fn delete_node(
            &self,
            request: tonic::Request<super::DeleteNodeRequest>,
        ) -> std::result::Result<
            tonic::Response<super::DeleteNodeResponse>,
            tonic::Status,
        >;
        /// Send heartbeat / 发送心跳
        async fn heartbeat(
            &self,
            request: tonic::Request<super::HeartbeatRequest>,
        ) -> std::result::Result<
            tonic::Response<super::HeartbeatResponse>,
            tonic::Status,
        >;
        /// List all nodes / 列出所有节点
        async fn list_nodes(
            &self,
            request: tonic::Request<super::ListNodesRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListNodesResponse>,
            tonic::Status,
        >;
        /// Get specific node / 获取特定节点
        async fn get_node(
            &self,
            request: tonic::Request<super::GetNodeRequest>,
        ) -> std::result::Result<tonic::Response<super::GetNodeResponse>, tonic::Status>;
        /// Update node resource information / 更新节点资源信息
        async fn update_node_resource(
            &self,
            request: tonic::Request<super::UpdateNodeResourceRequest>,
        ) -> std::result::Result<
            tonic::Response<super::UpdateNodeResourceResponse>,
            tonic::Status,
        >;
        /// Get node resource information / 获取节点资源信息
        async fn get_node_resource(
            &self,
            request: tonic::Request<super::GetNodeResourceRequest>,
        ) -> std::result::Result<
            tonic::Response<super::GetNodeResourceResponse>,
            tonic::Status,
        >;
        /// List node resources / 列出节点资源信息
        async fn list_node_resources(
            &self,
            request: tonic::Request<super::ListNodeResourcesRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListNodeResourcesResponse>,
            tonic::Status,
        >;
        /// Get node with resource information / 获取节点及其资源信息
        async fn get_node_with_resource(
            &self,
            request: tonic::Request<super::GetNodeWithResourceRequest>,
        ) -> std::result::Result<
            tonic::Response<super::GetNodeWithResourceResponse>,
            tonic::Status,
        >;
    }
    /// Node management service definition / 节点管理服务定义
    #[derive(Debug)]
    pub struct NodeServiceServer<T> {
        inner: Arc<T>,
        accept_compression_encodings: EnabledCompressionEncodings,
        send_compression_encodings: EnabledCompressionEncodings,
        max_decoding_message_size: Option<usize>,
        max_encoding_message_size: Option<usize>,
    }
    impl<T> NodeServiceServer<T> {
        pub fn new(inner: T) -> Self {
            Self::from_arc(Arc::new(inner))
        }
        pub fn from_arc(inner: Arc<T>) -> Self {
            Self {
                inner,
                accept_compression_encodings: Default::default(),
                send_compression_encodings: Default::default(),
                max_decoding_message_size: None,
                max_encoding_message_size: None,
            }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> InterceptedService<Self, F>
        where
            F: tonic::service::Interceptor,
        {
            InterceptedService::new(Self::new(inner), interceptor)
        }
        /// Enable decompressing requests with the given encoding.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.accept_compression_encodings.enable(encoding);
            self
        }
        /// Compress responses with the given encoding, if the client supports it.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.send_compression_encodings.enable(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.max_decoding_message_size = Some(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.max_encoding_message_size = Some(limit);
            self
        }
    }
    impl<T, B> tonic::codegen::Service<http::Request<B>> for NodeServiceServer<T>
    where
        T: NodeService,
        B: Body + std::marker::Send + 'static,
        B::Error: Into<StdError> + std::marker::Send + 'static,
    {
        type Response = http::Response<tonic::body::BoxBody>;
        type Error = std::convert::Infallible;
        type Future = BoxFuture<Self::Response, Self::Error>;
        fn poll_ready(
            &mut self,
            _cx: &mut Context<'_>,
        ) -> Poll<std::result::Result<(), Self::Error>> {
            Poll::Ready(Ok(()))
        }
        fn call(&mut self, req: http::Request<B>) -> Self::Future {
            match req.uri().path() {
                "/sms.NodeService/RegisterNode" => {
                    #[allow(non_camel_case_types)]
                    struct RegisterNodeSvc<T: NodeService>(pub Arc<T>);
                    impl<
                        T: NodeService,
                    > tonic::server::UnaryService<super::RegisterNodeRequest>
                    for RegisterNodeSvc<T> {
                        type Response = super::RegisterNodeResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::RegisterNodeRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as NodeService>::register_node(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = RegisterNodeSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/sms.NodeService/UpdateNode" => {
                    #[allow(non_camel_case_types)]
                    struct UpdateNodeSvc<T: NodeService>(pub Arc<T>);
                    impl<
                        T: NodeService,
                    > tonic::server::UnaryService<super::UpdateNodeRequest>
                    for UpdateNodeSvc<T> {
                        type Response = super::UpdateNodeResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::UpdateNodeRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as NodeService>::update_node(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = UpdateNodeSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/sms.NodeService/DeleteNode" => {
                    #[allow(non_camel_case_types)]
                    struct DeleteNodeSvc<T: NodeService>(pub Arc<T>);
                    impl<
                        T: NodeService,
                    > tonic::server::UnaryService<super::DeleteNodeRequest>
                    for DeleteNodeSvc<T> {
                        type Response = super::DeleteNodeResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::DeleteNodeRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as NodeService>::delete_node(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = DeleteNodeSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/sms.NodeService/Heartbeat" => {
                    #[allow(non_camel_case_types)]
                    struct HeartbeatSvc<T: NodeService>(pub Arc<T>);
                    impl<
                        T: NodeService,
                    > tonic::server::UnaryService<super::HeartbeatRequest>
                    for HeartbeatSvc<T> {
                        type Response = super::HeartbeatResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::HeartbeatRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as NodeService>::heartbeat(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = HeartbeatSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/sms.NodeService/ListNodes" => {
                    #[allow(non_camel_case_types)]
                    struct ListNodesSvc<T: NodeService>(pub Arc<T>);
                    impl<
                        T: NodeService,
                    > tonic::server::UnaryService<super::ListNodesRequest>
                    for ListNodesSvc<T> {
                        type Response = super::ListNodesResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::ListNodesRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as NodeService>::list_nodes(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = ListNodesSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/sms.NodeService/GetNode" => {
                    #[allow(non_camel_case_types)]
                    struct GetNodeSvc<T: NodeService>(pub Arc<T>);
                    impl<
                        T: NodeService,
                    > tonic::server::UnaryService<super::GetNodeRequest>
                    for GetNodeSvc<T> {
                        type Response = super::GetNodeResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::GetNodeRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as NodeService>::get_node(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = GetNodeSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/sms.NodeService/UpdateNodeResource" => {
                    #[allow(non_camel_case_types)]
                    struct UpdateNodeResourceSvc<T: NodeService>(pub Arc<T>);
                    impl<
                        T: NodeService,
                    > tonic::server::UnaryService<super::UpdateNodeResourceRequest>
                    for UpdateNodeResourceSvc<T> {
                        type Response = super::UpdateNodeResourceResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::UpdateNodeResourceRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as NodeService>::update_node_resource(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = UpdateNodeResourceSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/sms.NodeService/GetNodeResource" => {
                    #[allow(non_camel_case_types)]
                    struct GetNodeResourceSvc<T: NodeService>(pub Arc<T>);
                    impl<
                        T: NodeService,
                    > tonic::server::UnaryService<super::GetNodeResourceRequest>
                    for GetNodeResourceSvc<T> {
                        type Response = super::GetNodeResourceResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::GetNodeResourceRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as NodeService>::get_node_resource(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = GetNodeResourceSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/sms.NodeService/ListNodeResources" => {
                    #[allow(non_camel_case_types)]
                    struct ListNodeResourcesSvc<T: NodeService>(pub Arc<T>);
                    impl<
                        T: NodeService,
                    > tonic::server::UnaryService<super::ListNodeResourcesRequest>
                    for ListNodeResourcesSvc<T> {
                        type Response = super::ListNodeResourcesResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::ListNodeResourcesRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as NodeService>::list_node_resources(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = ListNodeResourcesSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/sms.NodeService/GetNodeWithResource" => {
                    #[allow(non_camel_case_types)]
                    struct GetNodeWithResourceSvc<T: NodeService>(pub Arc<T>);
                    impl<
                        T: NodeService,
                    > tonic::server::UnaryService<super::GetNodeWithResourceRequest>
                    for GetNodeWithResourceSvc<T> {
                        type Response = super::GetNodeWithResourceResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::GetNodeWithResourceRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as NodeService>::get_node_with_resource(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = GetNodeWithResourceSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                _ => {
                    Box::pin(async move {
                        let mut response = http::Response::new(empty_body());
                        let headers = response.headers_mut();
                        headers
                            .insert(
                                tonic::Status::GRPC_STATUS,
                                (tonic::Code::Unimplemented as i32).into(),
                            );
                        headers
                            .insert(
                                http::header::CONTENT_TYPE,
                                tonic::metadata::GRPC_CONTENT_TYPE,
                            );
                        Ok(response)
                    })
                }
            }
        }
    }
    impl<T> Clone for NodeServiceServer<T> {
        fn clone(&self) -> Self {
            let inner = self.inner.clone();
            Self {
                inner,
                accept_compression_encodings: self.accept_compression_encodings,
                send_compression_encodings: self.send_compression_encodings,
                max_decoding_message_size: self.max_decoding_message_size,
                max_encoding_message_size: self.max_encoding_message_size,
            }
        }
    }
    /// Generated gRPC service name
    pub const SERVICE_NAME: &str = "sms.NodeService";
    impl<T> tonic::server::NamedService for NodeServiceServer<T> {
        const NAME: &'static str = SERVICE_NAME;
    }
}
/// Task definition / 任务定义
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Task {
    /// Unique task identifier / 唯一任务标识符
    #[prost(string, tag = "1")]
    pub task_id: ::prost::alloc::string::String,
    /// Task name / 任务名称
    #[prost(string, tag = "2")]
    pub name: ::prost::alloc::string::String,
    /// Task description / 任务描述
    #[prost(string, tag = "3")]
    pub description: ::prost::alloc::string::String,
    /// Current task status / 当前任务状态
    #[prost(enumeration = "TaskStatus", tag = "4")]
    pub status: i32,
    /// Task priority / 任务优先级
    #[prost(enumeration = "TaskPriority", tag = "5")]
    pub priority: i32,
    /// Node UUID where task is registered / 任务注册的节点UUID
    #[prost(string, tag = "6")]
    pub node_uuid: ::prost::alloc::string::String,
    /// Task endpoint URL / 任务端点URL
    #[prost(string, tag = "7")]
    pub endpoint: ::prost::alloc::string::String,
    /// Task version / 任务版本
    #[prost(string, tag = "8")]
    pub version: ::prost::alloc::string::String,
    /// Task capabilities / 任务能力
    #[prost(string, repeated, tag = "9")]
    pub capabilities: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// Task registration timestamp / 任务注册时间戳
    #[prost(int64, tag = "10")]
    pub registered_at: i64,
    /// Last heartbeat timestamp / 最后心跳时间戳
    #[prost(int64, tag = "11")]
    pub last_heartbeat: i64,
    /// Additional task metadata / 额外任务元数据
    #[prost(map = "string, string", tag = "12")]
    pub metadata: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
    /// Task configuration / 任务配置
    #[prost(map = "string, string", tag = "13")]
    pub config: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
}
/// Task registration request / 任务注册请求
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RegisterTaskRequest {
    /// Task name / 任务名称
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Task description / 任务描述
    #[prost(string, tag = "2")]
    pub description: ::prost::alloc::string::String,
    /// Task priority / 任务优先级
    #[prost(enumeration = "TaskPriority", tag = "3")]
    pub priority: i32,
    /// Node UUID where task is registered / 任务注册的节点UUID
    #[prost(string, tag = "4")]
    pub node_uuid: ::prost::alloc::string::String,
    /// Task endpoint URL / 任务端点URL
    #[prost(string, tag = "5")]
    pub endpoint: ::prost::alloc::string::String,
    /// Task version / 任务版本
    #[prost(string, tag = "6")]
    pub version: ::prost::alloc::string::String,
    /// Task capabilities / 任务能力
    #[prost(string, repeated, tag = "7")]
    pub capabilities: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// Additional task metadata / 额外任务元数据
    #[prost(map = "string, string", tag = "8")]
    pub metadata: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
    /// Task configuration / 任务配置
    #[prost(map = "string, string", tag = "9")]
    pub config: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
}
/// Task registration response / 任务注册响应
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RegisterTaskResponse {
    /// Whether registration was successful / 注册是否成功
    #[prost(bool, tag = "1")]
    pub success: bool,
    /// Response message / 响应消息
    #[prost(string, tag = "2")]
    pub message: ::prost::alloc::string::String,
    /// Assigned task ID / 分配的任务ID
    #[prost(string, tag = "3")]
    pub task_id: ::prost::alloc::string::String,
    /// Registered task details / 注册的任务详情
    #[prost(message, optional, tag = "4")]
    pub task: ::core::option::Option<Task>,
}
/// List tasks request / 列出任务请求
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListTasksRequest {
    /// Filter by node UUID (optional) / 按节点UUID过滤（可选）
    #[prost(string, tag = "1")]
    pub node_uuid: ::prost::alloc::string::String,
    /// Filter by status (optional) / 按状态过滤（可选）
    #[prost(enumeration = "TaskStatus", tag = "2")]
    pub status_filter: i32,
    /// Filter by priority (optional) / 按优先级过滤（可选）
    #[prost(enumeration = "TaskPriority", tag = "3")]
    pub priority_filter: i32,
    /// Maximum number of tasks to return / 返回的最大任务数
    #[prost(int32, tag = "4")]
    pub limit: i32,
    /// Offset for pagination / 分页偏移量
    #[prost(int32, tag = "5")]
    pub offset: i32,
}
/// List tasks response / 列出任务响应
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListTasksResponse {
    /// List of tasks / 任务列表
    #[prost(message, repeated, tag = "1")]
    pub tasks: ::prost::alloc::vec::Vec<Task>,
    /// Total number of tasks / 任务总数
    #[prost(int32, tag = "2")]
    pub total_count: i32,
}
/// Get task request / 获取任务请求
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetTaskRequest {
    /// Task ID / 任务ID
    #[prost(string, tag = "1")]
    pub task_id: ::prost::alloc::string::String,
}
/// Get task response / 获取任务响应
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetTaskResponse {
    /// Whether task was found / 是否找到任务
    #[prost(bool, tag = "1")]
    pub found: bool,
    /// Task details / 任务详情
    #[prost(message, optional, tag = "2")]
    pub task: ::core::option::Option<Task>,
}
/// Unregister task request / 注销任务请求
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UnregisterTaskRequest {
    /// Task ID to unregister / 要注销的任务ID
    #[prost(string, tag = "1")]
    pub task_id: ::prost::alloc::string::String,
    /// Reason for unregistration / 注销原因
    #[prost(string, tag = "2")]
    pub reason: ::prost::alloc::string::String,
}
/// Unregister task response / 注销任务响应
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UnregisterTaskResponse {
    /// Whether unregistration was successful / 注销是否成功
    #[prost(bool, tag = "1")]
    pub success: bool,
    /// Response message / 响应消息
    #[prost(string, tag = "2")]
    pub message: ::prost::alloc::string::String,
    /// Unregistered task ID / 已注销的任务ID
    #[prost(string, tag = "3")]
    pub task_id: ::prost::alloc::string::String,
}
/// Task status enumeration / 任务状态枚举
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum TaskStatus {
    /// Unknown status / 未知状态
    Unknown = 0,
    /// Task is registered / 任务已注册
    Registered = 1,
    /// Task is active / 任务活跃
    Active = 2,
    /// Task is inactive / 任务非活跃
    Inactive = 3,
    /// Task is unregistered / 任务已注销
    Unregistered = 4,
}
impl TaskStatus {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unknown => "TASK_STATUS_UNKNOWN",
            Self::Registered => "TASK_STATUS_REGISTERED",
            Self::Active => "TASK_STATUS_ACTIVE",
            Self::Inactive => "TASK_STATUS_INACTIVE",
            Self::Unregistered => "TASK_STATUS_UNREGISTERED",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "TASK_STATUS_UNKNOWN" => Some(Self::Unknown),
            "TASK_STATUS_REGISTERED" => Some(Self::Registered),
            "TASK_STATUS_ACTIVE" => Some(Self::Active),
            "TASK_STATUS_INACTIVE" => Some(Self::Inactive),
            "TASK_STATUS_UNREGISTERED" => Some(Self::Unregistered),
            _ => None,
        }
    }
}
/// Task priority enumeration / 任务优先级枚举
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum TaskPriority {
    /// Unknown priority / 未知优先级
    Unknown = 0,
    /// Low priority / 低优先级
    Low = 1,
    /// Normal priority / 普通优先级
    Normal = 2,
    /// High priority / 高优先级
    High = 3,
    /// Urgent priority / 紧急优先级
    Urgent = 4,
}
impl TaskPriority {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unknown => "TASK_PRIORITY_UNKNOWN",
            Self::Low => "TASK_PRIORITY_LOW",
            Self::Normal => "TASK_PRIORITY_NORMAL",
            Self::High => "TASK_PRIORITY_HIGH",
            Self::Urgent => "TASK_PRIORITY_URGENT",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "TASK_PRIORITY_UNKNOWN" => Some(Self::Unknown),
            "TASK_PRIORITY_LOW" => Some(Self::Low),
            "TASK_PRIORITY_NORMAL" => Some(Self::Normal),
            "TASK_PRIORITY_HIGH" => Some(Self::High),
            "TASK_PRIORITY_URGENT" => Some(Self::Urgent),
            _ => None,
        }
    }
}
/// Generated client implementations.
pub mod task_service_client {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    /// Task service definition / 任务服务定义
    #[derive(Debug, Clone)]
    pub struct TaskServiceClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl TaskServiceClient<tonic::transport::Channel> {
        /// Attempt to create a new client by connecting to a given endpoint.
        pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
        where
            D: TryInto<tonic::transport::Endpoint>,
            D::Error: Into<StdError>,
        {
            let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
            Ok(Self::new(conn))
        }
    }
    impl<T> TaskServiceClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + std::marker::Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + std::marker::Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> TaskServiceClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
            >>::Error: Into<StdError> + std::marker::Send + std::marker::Sync,
        {
            TaskServiceClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// Register a new task / 注册新任务
        pub async fn register_task(
            &mut self,
            request: impl tonic::IntoRequest<super::RegisterTaskRequest>,
        ) -> std::result::Result<
            tonic::Response<super::RegisterTaskResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/sms.TaskService/RegisterTask",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("sms.TaskService", "RegisterTask"));
            self.inner.unary(req, path, codec).await
        }
        /// List tasks with optional filtering / 列出任务（可选过滤）
        pub async fn list_tasks(
            &mut self,
            request: impl tonic::IntoRequest<super::ListTasksRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListTasksResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/sms.TaskService/ListTasks",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new("sms.TaskService", "ListTasks"));
            self.inner.unary(req, path, codec).await
        }
        /// Get task details by ID / 根据ID获取任务详情
        pub async fn get_task(
            &mut self,
            request: impl tonic::IntoRequest<super::GetTaskRequest>,
        ) -> std::result::Result<
            tonic::Response<super::GetTaskResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static("/sms.TaskService/GetTask");
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new("sms.TaskService", "GetTask"));
            self.inner.unary(req, path, codec).await
        }
        /// Unregister a task / 注销任务
        pub async fn unregister_task(
            &mut self,
            request: impl tonic::IntoRequest<super::UnregisterTaskRequest>,
        ) -> std::result::Result<
            tonic::Response<super::UnregisterTaskResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/sms.TaskService/UnregisterTask",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("sms.TaskService", "UnregisterTask"));
            self.inner.unary(req, path, codec).await
        }
    }
}
/// Generated server implementations.
pub mod task_service_server {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    /// Generated trait containing gRPC methods that should be implemented for use with TaskServiceServer.
    #[async_trait]
    pub trait TaskService: std::marker::Send + std::marker::Sync + 'static {
        /// Register a new task / 注册新任务
        async fn register_task(
            &self,
            request: tonic::Request<super::RegisterTaskRequest>,
        ) -> std::result::Result<
            tonic::Response<super::RegisterTaskResponse>,
            tonic::Status,
        >;
        /// List tasks with optional filtering / 列出任务（可选过滤）
        async fn list_tasks(
            &self,
            request: tonic::Request<super::ListTasksRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListTasksResponse>,
            tonic::Status,
        >;
        /// Get task details by ID / 根据ID获取任务详情
        async fn get_task(
            &self,
            request: tonic::Request<super::GetTaskRequest>,
        ) -> std::result::Result<tonic::Response<super::GetTaskResponse>, tonic::Status>;
        /// Unregister a task / 注销任务
        async fn unregister_task(
            &self,
            request: tonic::Request<super::UnregisterTaskRequest>,
        ) -> std::result::Result<
            tonic::Response<super::UnregisterTaskResponse>,
            tonic::Status,
        >;
    }
    /// Task service definition / 任务服务定义
    #[derive(Debug)]
    pub struct TaskServiceServer<T> {
        inner: Arc<T>,
        accept_compression_encodings: EnabledCompressionEncodings,
        send_compression_encodings: EnabledCompressionEncodings,
        max_decoding_message_size: Option<usize>,
        max_encoding_message_size: Option<usize>,
    }
    impl<T> TaskServiceServer<T> {
        pub fn new(inner: T) -> Self {
            Self::from_arc(Arc::new(inner))
        }
        pub fn from_arc(inner: Arc<T>) -> Self {
            Self {
                inner,
                accept_compression_encodings: Default::default(),
                send_compression_encodings: Default::default(),
                max_decoding_message_size: None,
                max_encoding_message_size: None,
            }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> InterceptedService<Self, F>
        where
            F: tonic::service::Interceptor,
        {
            InterceptedService::new(Self::new(inner), interceptor)
        }
        /// Enable decompressing requests with the given encoding.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.accept_compression_encodings.enable(encoding);
            self
        }
        /// Compress responses with the given encoding, if the client supports it.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.send_compression_encodings.enable(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.max_decoding_message_size = Some(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.max_encoding_message_size = Some(limit);
            self
        }
    }
    impl<T, B> tonic::codegen::Service<http::Request<B>> for TaskServiceServer<T>
    where
        T: TaskService,
        B: Body + std::marker::Send + 'static,
        B::Error: Into<StdError> + std::marker::Send + 'static,
    {
        type Response = http::Response<tonic::body::BoxBody>;
        type Error = std::convert::Infallible;
        type Future = BoxFuture<Self::Response, Self::Error>;
        fn poll_ready(
            &mut self,
            _cx: &mut Context<'_>,
        ) -> Poll<std::result::Result<(), Self::Error>> {
            Poll::Ready(Ok(()))
        }
        fn call(&mut self, req: http::Request<B>) -> Self::Future {
            match req.uri().path() {
                "/sms.TaskService/RegisterTask" => {
                    #[allow(non_camel_case_types)]
                    struct RegisterTaskSvc<T: TaskService>(pub Arc<T>);
                    impl<
                        T: TaskService,
                    > tonic::server::UnaryService<super::RegisterTaskRequest>
                    for RegisterTaskSvc<T> {
                        type Response = super::RegisterTaskResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::RegisterTaskRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as TaskService>::register_task(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = RegisterTaskSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/sms.TaskService/ListTasks" => {
                    #[allow(non_camel_case_types)]
                    struct ListTasksSvc<T: TaskService>(pub Arc<T>);
                    impl<
                        T: TaskService,
                    > tonic::server::UnaryService<super::ListTasksRequest>
                    for ListTasksSvc<T> {
                        type Response = super::ListTasksResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::ListTasksRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as TaskService>::list_tasks(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = ListTasksSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/sms.TaskService/GetTask" => {
                    #[allow(non_camel_case_types)]
                    struct GetTaskSvc<T: TaskService>(pub Arc<T>);
                    impl<
                        T: TaskService,
                    > tonic::server::UnaryService<super::GetTaskRequest>
                    for GetTaskSvc<T> {
                        type Response = super::GetTaskResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::GetTaskRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as TaskService>::get_task(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = GetTaskSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/sms.TaskService/UnregisterTask" => {
                    #[allow(non_camel_case_types)]
                    struct UnregisterTaskSvc<T: TaskService>(pub Arc<T>);
                    impl<
                        T: TaskService,
                    > tonic::server::UnaryService<super::UnregisterTaskRequest>
                    for UnregisterTaskSvc<T> {
                        type Response = super::UnregisterTaskResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::UnregisterTaskRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as TaskService>::unregister_task(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = UnregisterTaskSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                _ => {
                    Box::pin(async move {
                        let mut response = http::Response::new(empty_body());
                        let headers = response.headers_mut();
                        headers
                            .insert(
                                tonic::Status::GRPC_STATUS,
                                (tonic::Code::Unimplemented as i32).into(),
                            );
                        headers
                            .insert(
                                http::header::CONTENT_TYPE,
                                tonic::metadata::GRPC_CONTENT_TYPE,
                            );
                        Ok(response)
                    })
                }
            }
        }
    }
    impl<T> Clone for TaskServiceServer<T> {
        fn clone(&self) -> Self {
            let inner = self.inner.clone();
            Self {
                inner,
                accept_compression_encodings: self.accept_compression_encodings,
                send_compression_encodings: self.send_compression_encodings,
                max_decoding_message_size: self.max_decoding_message_size,
                max_encoding_message_size: self.max_encoding_message_size,
            }
        }
    }
    /// Generated gRPC service name
    pub const SERVICE_NAME: &str = "sms.TaskService";
    impl<T> tonic::server::NamedService for TaskServiceServer<T> {
        const NAME: &'static str = SERVICE_NAME;
    }
}
